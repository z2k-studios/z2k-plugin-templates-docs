import fs from "fs-extra";
import path from "path";
import { FileIndexEntry, FolderIndexEntry, Index } from "./types.ts";
import * as utils from "./utils.ts";

export const SIDEBAR_PATH = path.join(utils.DEST, "../sidebars.ts");
export const DEBUG_TREE_PATH = path.join(utils.DEST, "debug/docs-tree.txt");

// ====================================================================================================
// Step 3: Generate Sidebar + Debug Tree
// ====================================================================================================
/**
 * Consumes the `Index` built in Step 2 and produces:
 *  - `sidebars.ts` for Docusaurus, defining categories and docs
 *  - A debug file `docs/debug/docs-tree.txt` with a Unix `tree`-like view of how
 *    the sidebar structure will appear (with file positions and names).
 *
 * Key points:
 * - Each folder is represented as a Docusaurus category.
 * - Category ordering is controlled by folder-level metadata (`folder_position`).
 * - Doc ordering inside categories is controlled by YAML `sidebar_position`.
 * - Sorting happens before writing to disk, so the debug tree matches final sidebar order.
 * - Non-doc files (e.g., `.jpg`, `.gif`, `.log`) are ignored for sidebar purposes.
 * 
 * At the root level, both categories (folders) and docs are merged into a single
 * sorted list using the same comparator as inside categories:
 *   - Positioned items (>= 0) first, ascending.
 *   - Unset positions ("auto") afterward, alphabetical.
 *
 * This ensures a doc at pos=1 appears above categories at pos=10, etc.
 *
 * @param index - The index produced by step2-buildIndex.ts
 */
export function generateSidebar(index: Index) {
  // Build quick lookup: folderPath → folder entry
  const folderMap = new Map<string, FolderIndexEntry>();
  for (const folder of index.folders) {
    folderMap.set(folder.sourcePath, folder);
  }

  // Build quick lookup: folderPath → files
  const filesByFolder = new Map<string, FileIndexEntry[]>();
  for (const file of index.files) {
    const arr = filesByFolder.get(file.sourceDir) || [];
    arr.push(file);
    filesByFolder.set(file.sourceDir, arr);
  }

  // Recursively build category tree beginning at the *logical* root(s)
  const rootFolders = index.folders.filter((f) => f.destDir === "");
  const sidebarItems: any[] = [];

  for (const root of rootFolders) {
    type Child =
      | { kind: "doc"; pos: number; label: string; value: FileIndexEntry }
      | { kind: "folder"; pos: number; label: string; value: FolderIndexEntry };

    const children: Child[] = [];

    // --- Collect subfolders (categories) ---
    const subfolders = index.folders.filter(
      (f) => path.dirname(f.sourcePath) === root.sourcePath
    );
    for (const sub of subfolders) {
      children.push({
        kind: "folder",
        pos: sub.sidebarPosition,
        label: sub.destTitle,
        value: sub,
      });
    }

    // --- Collect root-level docs ---
    const rootFiles = (filesByFolder.get(root.sourcePath) || []).filter((f) =>
      utils.isMarkdownOrText(f.destSlug)
    );
    for (const file of rootFiles) {
      children.push({
        kind: "doc",
        pos: file.sidebarPosition,
        label: file.destTitle,
        value: file,
      });
    }

    // --- Sort docs + folders together ---
    children.sort((a, b) => cmpByPosThenLabel(a, b, (x) => x.pos, (x) => x.label));

    // --- Emit final order ---
    for (const c of children) {
      if (c.kind === "doc") {
        sidebarItems.push({
          type: "doc",
          id: buildDocId(c.value, folderMap),
          label: c.value.destTitle,
        });
      } else {
        sidebarItems.push(buildCategory(c.value, index, folderMap, filesByFolder));
      }
    }
  }

  // Write sidebars.ts (no position fields emitted; positions are used only for sorting)
  const sidebarsExport = `//
// Auto-generated by import-obsidian inside step3-generateSidebar.ts
// Do not edit directly - modifications will be overwritten
//
import type { SidebarsConfig } from '@docusaurus/plugin-content-docs';

const sidebars: SidebarsConfig = {
  'z2k-templates-docs': ${JSON.stringify(sidebarItems, null, 2)}
};

export default sidebars;
`;
  fs.writeFileSync(SIDEBAR_PATH, sidebarsExport, "utf8");
  console.log(`✅ Sidebar written to ${SIDEBAR_PATH}`);

  // Write debug docs-tree.txt (directory is ensured)
  const treeOutput = buildDebugTree(index, folderMap, filesByFolder);
  writeDebugTree(DEBUG_TREE_PATH, treeOutput);
  console.log(`✅ Debug tree written to ${DEBUG_TREE_PATH}`);
}

// ====================================================================================================
// Helper: buildCategory (merged sorting of docs + subfolders)
// ====================================================================================================
/**
 * Builds a single Docusaurus category from a folder entry.
 * Includes:
 *  - Link to the folder’s index doc if present (index.md, readme.md, or same-name doc).
 *  - All child docs and subfolders sorted *together* by sidebar_position.
 *    Positioned items come first, autos after (alphabetical).
 * 
 * Note:
 * - We *do not* emit any `position` fields in the final sidebar; Docusaurus v3 rejects
 *   category positions. All ordering is resolved here, before writing.
 *
 * @param folder - Folder index entry
 * @param index - Full index of all files/folders
 * @param folderMap - Lookup map of folderPath → folder entry
 * @param filesByFolder - Lookup map of folderPath → files
 * @returns A Docusaurus sidebar category object
 */
function buildCategory(
  folder: FolderIndexEntry,
  index: Index,
  folderMap: Map<string, FolderIndexEntry>,
  filesByFolder: Map<string, FileIndexEntry[]>
): any {
  const folderFiles = (filesByFolder.get(folder.sourcePath) || []).slice();

  // Look for an index doc that the category should link to
  const indexFile = folderFiles.find(
    (f) =>
      f.sourceName.toLowerCase() === "index" ||
      f.sourceName.toLowerCase() === "readme" ||
      f.sourceName.toLowerCase() === folder.sourceName.toLowerCase()
  );

  const category: any = {
    type: "category",
    label: folder.destTitle,
    items: [] as any[],
  };

  // Category-level link points to its index file (if one exists and is a doc file)
  if (indexFile && utils.isMarkdownOrText(indexFile.destSlug)) {
    category.link = {
      type: "doc",
      id: buildDocId(indexFile, folderMap),
    };
  }

  // --- Merge docs and subfolders into one array ---
  type Child =
    | { kind: "doc"; pos: number; label: string; value: FileIndexEntry }
    | { kind: "folder"; pos: number; label: string; value: FolderIndexEntry };

  const children: Child[] = [];

  // Non-index docs
  const nonIndexDocs = folderFiles.filter(
    (f) => f !== indexFile && utils.isMarkdownOrText(f.destSlug)
  );
  for (const file of nonIndexDocs) {
    children.push({
      kind: "doc",
      pos: file.sidebarPosition,
      label: file.destTitle,
      value: file,
    });
  }

  // Subfolders
  const subfolders = index.folders.filter(
    (f) => path.dirname(f.sourcePath) === folder.sourcePath
  );
  for (const sub of subfolders) {
    children.push({
      kind: "folder",
      pos: sub.sidebarPosition,
      label: sub.destTitle,
      value: sub,
    });
  }

  // Sort docs + subfolders together
  children.sort((a, b) => cmpByPosThenLabel(a, b, (x) => x.pos, (x) => x.label));

  // Emit children in final order
  for (const c of children) {
    if (c.kind === "doc") {
      category.items.push({
        type: "doc",
        id: buildDocId(c.value, folderMap),
        label: c.value.destTitle,
      });
    } else {
      category.items.push(
        buildCategory(c.value, index, folderMap, filesByFolder)
      );
    }
  }

  return category;
}



// ====================================================================================================
// Helper: buildDocId
// ====================================================================================================
/**
 * Builds the Docusaurus `id` for a doc by walking up the folder tree
 * and concatenating folder slugs with the file slug.
 *
 * Example:
 *   docs/010-how-to-guides/020-beginner/beginner.md
 *   → id: "how-to-guides/beginner/beginner"
 *
 * Note:
 * - We currently strip only a trailing `.md` from the file slug to form the id.
 *   If you intend to surface `.txt` files as docs, you may wish to extend this
 *   to strip `.txt` as well (or convert them to `.md` earlier in the pipeline).
 */
function buildDocId(
  file: FileIndexEntry,
  folderMap: Map<string, FolderIndexEntry>
): string {
  const parts: string[] = [file.destSlug.replace(/\.md$/, "")];
  let currentDir = file.sourceDir;

  while (folderMap.has(currentDir)) {
    const folder = folderMap.get(currentDir)!;
    if (folder.destSlug && folder.destSlug !== "docs") {
      parts.unshift(folder.destSlug);
    }
    const parent = path.dirname(currentDir);
    if (parent === currentDir) break;
    currentDir = parent;
  }

  return parts.join("/");
}

// ====================================================================================================
// Helper: buildDebugTree
// ====================================================================================================
/**
 * Builds a Unix `tree`-like text view of the sidebar structure.
 * Each entry is shown in the order it will appear in the sidebar (shared comparator).
 * Each line shows:
 *  - The label
 *  - The position (explicit number or "auto")
 *  - The filename (for docs)
 *
 * Example:
 * ├── How-To Guides (pos=10)
 * │   ├── Getting Started (pos=1, "getting-started.md")
 * │   └── Beginner (pos=auto, "beginner.md")
 */
function buildDebugTree(
  index: Index,
  folderMap: Map<string, FolderIndexEntry>,
  filesByFolder: Map<string, FileIndexEntry[]>
): string {
  function walk(folder: FolderIndexEntry, prefix: string = ""): string {
    let output = `${prefix}${folder.destTitle} (pos=${fmtPos(folder.sidebarPosition)})\n`;

    const folderFiles = (filesByFolder.get(folder.sourcePath) || []).slice();

    const indexFile = folderFiles.find(
      (f) =>
        f.sourceName.toLowerCase() === "index" ||
        f.sourceName.toLowerCase() === "readme" ||
        f.sourceName.toLowerCase() === folder.sourceName.toLowerCase()
    );

    const nonIndexDocs = folderFiles
      .filter((f) => f !== indexFile && utils.isMarkdownOrText(f.destSlug))
      .sort((a, b) => cmpByPosThenLabel(a, b, x => x.sidebarPosition, x => x.destTitle));

    for (const file of nonIndexDocs) {
      output += `${prefix}  ├── ${file.destTitle} (pos=${fmtPos(file.sidebarPosition)}, "${file.sourceName}${file.sourceExt}")\n`;
    }

    const subfolders = index.folders
      .filter((f) => path.dirname(f.sourcePath) === folder.sourcePath)
      .sort((a, b) => cmpByPosThenLabel(a, b, x => x.sidebarPosition, x => x.destTitle));

    for (const sub of subfolders) {
      output += walk(sub, prefix + "  ");
    }

    return output;
  }

  const rootFolders = index.folders.filter((f) => f.destDir === "");
  let result = "";

  for (const root of rootFolders) {
    const subfolders = index.folders
      .filter((f) => path.dirname(f.sourcePath) === root.sourcePath)
      .sort((a, b) => cmpByPosThenLabel(a, b, x => x.sidebarPosition, x => x.destTitle));
    for (const sub of subfolders) {
      result += walk(sub);
    }

    // Include root-level docs, ordered with the same comparator
    const rootFiles = (filesByFolder.get(root.sourcePath) || [])
      .filter(f => utils.isMarkdownOrText(f.destSlug))
      .sort((a, b) => cmpByPosThenLabel(a, b, x => x.sidebarPosition, x => x.destTitle));
    for (const file of rootFiles) {
      result += `  ├── ${file.destTitle} (pos=${fmtPos(file.sidebarPosition)}, "${file.sourceName}${file.sourceExt}")\n`;
    }
  }
  return result;
}

// ====================================================================================================
// Helper: writeDebugTree
// ====================================================================================================
/**
 * Writes the debug tree content to the specified output path,
 * ensuring that the parent directory exists.
 *
 * @param outputPath - The file path where the debug tree should be written.
 * @param content - The content of the debug tree to write.
 */
function writeDebugTree(outputPath: string, content: string) {
  fs.ensureDirSync(path.dirname(outputPath));
  fs.writeFileSync(outputPath, content, 'utf8');
}



// ====================================================================================================
// Sorting + Formatting Helpers
// ====================================================================================================
// These helpers centralize the ordering policy so both the sidebar *and* the debug tree
// use the exact same comparators. This guarantees the debug output matches the final
// sidebar order byte-for-byte.
//
// Policy (deterministic):
// - For both folders (categories) and docs:
//   1) Items with an explicit position (>= 0) are sorted ascending.
//   2) Items without a position (unset / -1) are considered "auto" and placed *after* all
//      positioned items, then sorted alphabetically by display label (numeric-aware).
// - We also emit console warnings whenever any "auto" items are alphabetized,
//   so you know where explicit positions are missing.
// ----------------------------------------------------------------------------------------------------
function posOrInfinity(n: number) {
  return (typeof n === 'number' && n >= 0) ? n : Number.POSITIVE_INFINITY;
}

function cmpByPosThenLabel<T>(
  a: T, b: T,
  getPos: (x: T) => number,
  getLabel: (x: T) => string
) {
  const ap = posOrInfinity(getPos(a));
  const bp = posOrInfinity(getPos(b));
  if (ap !== bp) return ap - bp;
  // Stable lexical fallback; case-insensitive, numeric-aware
  return getLabel(a).localeCompare(getLabel(b), undefined, { numeric: true, sensitivity: 'base' });
}

function isAuto(n: number) {
  return !(typeof n === 'number' && n >= 0);
}

function fmtPos(n: number) {
  return isAuto(n) ? 'auto' : String(n);
}

function warnIfAutos(kind: 'docs'|'folders', where: string, countAuto: number, total: number) {
  if (countAuto > 0) {
    console.warn(
      `[warn] ${kind} in ${where}: ${countAuto}/${total} lack positions; ` +
      `auto-ordering alphabetically after positioned items.`
    );
  }
}
