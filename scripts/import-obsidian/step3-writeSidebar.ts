import fs from "fs-extra";
import path from "path";
import { FileIndexEntry, FolderIndexEntry, Index } from "./types.ts";
import * as utils from "./utils.ts";

export const SIDEBAR_PATH = path.join(utils.DEST, "../sidebars.ts");
export const DEBUG_TREE_PATH = path.join(utils.DEST, "debug/docs-tree.txt");

// ====================================================================================================
// Step 3: Generate Sidebar + Debug Tree
// ====================================================================================================
/**
 * Consumes the `Index` built in Step 2 and produces:
 *  - `sidebars.ts` for Docusaurus, defining categories and docs
 *  - A debug file `docs/debug/docs-tree.txt` with a Unix `tree`-like view of how
 *    the sidebar structure will appear (with file positions and names).
 *
 * Key points:
 * - Each folder is represented as a Docusaurus category.
 * - Category ordering is controlled by folder-level metadata (`folder_position`).
 * - Doc ordering inside categories is controlled by YAML `sidebar_position`.
 * - Sorting happens before writing to disk, so the debug tree matches final sidebar order.
 * - Non-doc files (e.g., `.jpg`, `.gif`, `.log`) are ignored for sidebar purposes.
 *
 * @param index - The index produced by step2-buildIndex.ts
 */
export function generateSidebar(index: Index) {
  // Build quick lookup: folderPath → folder entry
  const folderMap = new Map<string, FolderIndexEntry>();
  for (const folder of index.folders) {
    folderMap.set(folder.sourcePath, folder);
  }

  // Build quick lookup: folderPath → files
  const filesByFolder = new Map<string, FileIndexEntry[]>();
  for (const file of index.files) {
    const arr = filesByFolder.get(file.sourceDir) || [];
    arr.push(file);
    filesByFolder.set(file.sourceDir, arr);
  }

  // Recursively build category tree
  const rootFolders = index.folders.filter((f) => f.destDir === "");
  const sidebarItems: any[] = [];

  for (const root of rootFolders) {
    const subfolders = index.folders.filter(
      (f) => path.dirname(f.sourcePath) === root.sourcePath
    );
    for (const sub of subfolders) {
      sidebarItems.push(buildCategory(sub, index, folderMap, filesByFolder));
    }

    const rootFiles = filesByFolder.get(root.sourcePath) || [];
    for (const file of rootFiles) {
      if (!utils.isMarkdownOrText(file.destSlug)) continue;
      sidebarItems.push({
        type: "doc",
        id: buildDocId(file, folderMap),
        label: file.destTitle,
      });
    }
  }

  // Write sidebar.ts
  const sidebarsExport = `//
// Auto-generated by import-obsidian inside step3-generateSidebar.ts
// Do not edit directly - modifications will be overwritten
//
import type { SidebarsConfig } from '@docusaurus/plugin-content-docs';

const sidebars: SidebarsConfig = {
  'z2k-templates-docs': ${JSON.stringify(sidebarItems, null, 2)}
};

export default sidebars;
`;

  fs.writeFileSync(SIDEBAR_PATH, sidebarsExport, "utf8");
  console.log(`✅ Sidebar written to ${SIDEBAR_PATH}`);

  // Write debug docs-tree.txt
  const treeOutput = buildDebugTree(index, folderMap, filesByFolder);
  writeDebugTree(path.join(utils.DEST, 'debug/docs-tree.txt'), treeOutput);
  fs.writeFileSync(DEBUG_TREE_PATH, treeOutput, "utf8");
  console.log(`✅ Debug tree written to ${DEBUG_TREE_PATH}`);
}

// ====================================================================================================
// Helper: buildCategory
// ====================================================================================================
/**
 * Builds a single Docusaurus category from a folder entry.
 * Includes:
 *  - Link to the folder’s index doc if present (index.md, readme.md, or same-name doc).
 *  - All child docs (sorted by sidebar_position).
 *  - All subfolders recursively.
 *
 * @param folder - Folder index entry
 * @param index - Full index of all files/folders
 * @param folderMap - Lookup map of folderPath → folder entry
 * @param filesByFolder - Lookup map of folderPath → files
 * @returns A Docusaurus sidebar category object
 */
function buildCategory(
  folder: FolderIndexEntry,
  index: Index,
  folderMap: Map<string, FolderIndexEntry>,
  filesByFolder: Map<string, FileIndexEntry[]>
): any {
  const folderFiles = filesByFolder.get(folder.sourcePath) || [];

  // Look for an index doc
  const indexFile = folderFiles.find(
    (f) =>
      f.sourceName.toLowerCase() === "index" ||
      f.sourceName.toLowerCase() === "readme" ||
      f.sourceName.toLowerCase() === folder.sourceName.toLowerCase()
  );

  const category: any = {
    type: "category",
    label: folder.destTitle,
    items: [] as any[],
  };

  // Category-level link points to its index file
  if (indexFile && utils.isMarkdownOrText(indexFile.destSlug)) {
    category.link = {
      type: "doc",
      id: buildDocId(indexFile, folderMap),
    };
  }

  // Docs: add all non-index files
  const nonIndexDocs = folderFiles
    .filter((f) => f !== indexFile && utils.isMarkdownOrText(f.destSlug))
    .sort((a, b) => a.sidebarPosition - b.sidebarPosition);

  for (const file of nonIndexDocs) {
    category.items.push({
      type: "doc",
      id: buildDocId(file, folderMap),
      label: file.destTitle,
    });
  }

  // Subfolders: recursively add categories
  const subfolders = index.folders
    .filter((f) => path.dirname(f.sourcePath) === folder.sourcePath)
    .sort((a, b) => a.sidebarPosition - b.sidebarPosition);

  for (const sub of subfolders) {
    category.items.push(buildCategory(sub, index, folderMap, filesByFolder));
  }

  return category;
}

// ====================================================================================================
// Helper: buildDocId
// ====================================================================================================
/**
 * Builds the Docusaurus `id` for a doc by walking up the folder tree
 * and concatenating folder slugs with the file slug.
 *
 * Example:
 *   docs/010-how-to-guides/020-beginner/beginner.md
 *   → id: "how-to-guides/beginner/beginner"
 */
function buildDocId(
  file: FileIndexEntry,
  folderMap: Map<string, FolderIndexEntry>
): string {
  const parts: string[] = [file.destSlug.replace(/\.md$/, "")];
  let currentDir = file.sourceDir;

  while (folderMap.has(currentDir)) {
    const folder = folderMap.get(currentDir)!;
    if (folder.destSlug && folder.destSlug !== "docs") {
      parts.unshift(folder.destSlug);
    }
    const parent = path.dirname(currentDir);
    if (parent === currentDir) break;
    currentDir = parent;
  }

  return parts.join("/");
}

// ====================================================================================================
// Helper: buildDebugTree
// ====================================================================================================
/**
 * Builds a Unix `tree`-like text view of the sidebar structure.
 * Each entry is shown in the order it will appear in the sidebar.
 * Each line shows:
 *  - The label
 *  - The `sidebar_position` (if present, otherwise "auto")
 *  - The filename (for docs)
 *
 * Example:
 * ├── how-to-guides (pos=10)
 * │   ├── getting-started.md (pos=1, "Getting Started")
 * │   └── beginner.md (pos=2, "Beginner")
 */
function buildDebugTree(
  index: Index,
  folderMap: Map<string, FolderIndexEntry>,
  filesByFolder: Map<string, FileIndexEntry[]>
): string {
  function walk(folder: FolderIndexEntry, prefix: string = ""): string {
    let output = `${prefix}${folder.destTitle} (pos=${folder.sidebarPosition})\n`;

    const folderFiles = (filesByFolder.get(folder.sourcePath) || []).slice();

    const indexFile = folderFiles.find(
      (f) =>
        f.sourceName.toLowerCase() === "index" ||
        f.sourceName.toLowerCase() === "readme" ||
        f.sourceName.toLowerCase() === folder.sourceName.toLowerCase()
    );

    const nonIndexDocs = folderFiles
      .filter((f) => f !== indexFile && utils.isMarkdownOrText(f.destSlug))
      .sort((a, b) => a.sidebarPosition - b.sidebarPosition);

    for (const file of nonIndexDocs) {
      output += `${prefix}  ├── ${file.destTitle} (pos=${file.sidebarPosition}, "${file.sourceName}${file.sourceExt}")\n`;
    }

    const subfolders = index.folders
      .filter((f) => path.dirname(f.sourcePath) === folder.sourcePath)
      .sort((a, b) => a.sidebarPosition - b.sidebarPosition);

    for (const sub of subfolders) {
      output += walk(sub, prefix + "  ");
    }

    return output;
  }

  const rootFolders = index.folders.filter((f) => f.destDir === "");
  let result = "";
  for (const root of rootFolders) {
    const subfolders = index.folders.filter(
      (f) => path.dirname(f.sourcePath) === root.sourcePath
    );
    for (const sub of subfolders) {
      result += walk(sub);
    }
  }
  return result;
}

// ====================================================================================================
// Helper: writeDebugTree
// ====================================================================================================
/**
 * Writes the debug tree content to the specified output path,
 * ensuring that the parent directory exists.
 *
 * @param outputPath - The file path where the debug tree should be written.
 * @param content - The content of the debug tree to write.
 */
function writeDebugTree(outputPath: string, content: string) {
  // Ensure parent directory exists
  fs.ensureDirSync(path.dirname(outputPath));
  fs.writeFileSync(outputPath, content, 'utf8');
}